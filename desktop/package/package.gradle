import java.time.LocalDateTime
import org.apache.tools.ant.taskdefs.condition.Os

import static groovy.io.FileType.*


task jpackageSanityChecks {
    description 'Interactive sanity checks on the version of the code that will be packaged'

    doLast {
        executeCmd("git --no-pager log -5 --oneline")
        ant.input(message: "Above you see the current HEAD and its recent history.\n" +
                "Is this the right commit for packaging? (y=continue, n=abort)",
                addproperty: "sanity-check-1",
                validargs: "y,n")
        if (ant.properties['sanity-check-1'] == 'n') {
            ant.fail('Aborting')
        }

        executeCmd("git status --short --branch")
        ant.input(message: "Above you see any local changes that are not in the remote branch.\n" +
                "If you have any local changes, please abort, get them merged, get the latest branch and try again.\n" +
                "Continue with packaging? (y=continue, n=abort)",
                addproperty: "sanity-check-2",
                validargs: "y,n")
        if (ant.properties['sanity-check-2'] == 'n') {
            ant.fail('Aborting')
        }

        // TODO Evtl check programmatically in gradle (i.e. fail if below v11)
        executeCmd("java --version")
        ant.input(message: "Above you see the installed java version, which will be used to compile and build Bisq.\n" +
                "Is this java version ok for that? (y=continue, n=abort)",
                addproperty: "sanity-check-3",
                validargs: "y,n")
        if (ant.properties['sanity-check-3'] == 'n') {
            ant.fail('Aborting')
        }
    }
}

task getJavaBinariesDownloadURLs {
    description 'Find out which JDK will be used for jpackage and prepare to download it'
    dependsOn 'jpackageSanityChecks'

    doLast {
        // The build directory will be deleted next time the clean task runs
        // Therefore, we can use it to store any temp files (separate JDK for jpackage, etc) and resulting build artefacts
        // We create a temp folder in the build directory which holds all jpackage-related artefacts (not just the final installers)
        String tempRootDirName = 'temp-' + LocalDateTime.now().format('yyyy.MM.dd-HHmmssSSS')
        File tempRootDir = new File(project.buildDir, tempRootDirName)
        tempRootDir.mkdirs()
        ext.tempRootDir = tempRootDir
        println "Created temp root folder " + tempRootDir

        File binariesFolderPath = new File(tempRootDir, "binaries")
        binariesFolderPath.mkdirs();
        ext.binariesFolderPath = binariesFolderPath

        // TODO Extend script logic to alternatively allow a local (separate, v14+) JDK for jpackage
        // TODO Another option is to use the local JDK for everything: build jars and use jpackage (but then it has to be v14+)

        // Define the download URLs (and associated binary hashes) for the JDK used to package the installers
        // These JDKs are independent of what is installed on the building system
        //
        // If these specific versions are not hosted by AdoptOpenJDK anymore, or if different versions are desired,
        // simply update the links and associated hashes below
        //
        // See https://adoptopenjdk.net/releases.html?variant=openjdk15&jvmVariant=hotspot for latest download URLs
        // On the download page linked above, filter as follows to get the binary URL + associated SHA256:
        // - architecture: x64
        // - operating system:
        // -- linux   ( -> use the tar.gz JDK link)
        // -- macOS   ( -> use the tar.gz JDK link)
        // -- windows ( -> use the .zip JDK link)
        Map jdk15Binaries = [
            'linux'   : 'https://github.com/AdoptOpenJDK/openjdk15-binaries/releases/download/jdk-15.0.1%2B9/OpenJDK15U-jdk_x64_linux_hotspot_15.0.1_9.tar.gz',
            'linux-sha256'   : '61045ecb9434e3320dbc2c597715f9884586b7a18a56d29851b4d4a4d48a2a5e',
            'mac'     : 'https://github.com/AdoptOpenJDK/openjdk15-binaries/releases/download/jdk-15.0.1%2B9.1/OpenJDK15U-jdk_x64_mac_hotspot_15.0.1_9.tar.gz',
            'mac-sha256'     : 'b8c2e2ad31f3d6676ea665d9505b06df15e23741847556612b40e3ee329fc046',
            'windows' : 'https://github.com/AdoptOpenJDK/openjdk15-binaries/releases/download/jdk-15.0.1%2B9/OpenJDK15U-jdk_x64_windows_hotspot_15.0.1_9.zip',
            'windows-sha256' : '0cd7e61b0a37186902062a822caa0e14662b676c245b7ebe541f115f3c45681a'

            // TODO For some reason, using "--runtime-image jdk-11" does NOT work with a v15 jpackage, but works with v14
            // v14
//            'linux'   : 'https://github.com/AdoptOpenJDK/openjdk14-binaries/releases/download/jdk-14.0.2%2B12/OpenJDK14U-jdk_x64_linux_hotspot_14.0.2_12.tar.gz',
//            'linux-sha256'   : '7d5ee7e06909b8a99c0d029f512f67b092597aa5b0e78c109bd59405bbfa74fe',
//            'mac'     : 'https://github.com/AdoptOpenJDK/openjdk14-binaries/releases/download/jdk-14.0.2%2B12/OpenJDK14U-jdk_x64_mac_hotspot_14.0.2_12.tar.gz',
//            'mac-sha256'     : '09b7e6ab5d5eb4b73813f4caa793a0b616d33794a17988fa6a6b7c972e8f3dd3',
//            'windows' : 'https://github.com/AdoptOpenJDK/openjdk14-binaries/releases/download/jdk-14.0.2%2B12/OpenJDK14U-jdk_x64_windows_hotspot_14.0.2_12.zip',
//            'windows-sha256' : '80926003297bf5afc9357ce24c12aee65483fc7889dc34b65fe08bec4d040611'
        ]

        String osKey
        if (Os.isFamily(Os.FAMILY_WINDOWS)) {
            osKey = 'windows'
        } else if (Os.isFamily(Os.FAMILY_MAC)) {
            osKey = 'mac'
        } else {
            osKey = 'linux'
        }

        ext.jdk15Binary_DownloadURL = jdk15Binaries[osKey]
        ext.jdk15Binary_SHA256Hash = jdk15Binaries[osKey + '-sha256']
    }
}

task retrieveAndExtractJavaBinaries {
    description 'Retrieve necessary Java binaries and extract them'
    dependsOn 'getJavaBinariesDownloadURLs'

    doLast {
        File tempRootDir = getJavaBinariesDownloadURLs.property("tempRootDir")

        // Folder where the jpackage JDK archive will be downloaded and extracted
        String jdkForJpackageDirName = "jdk-jpackage"
        File jdkForJpackageDir = new File(tempRootDir, jdkForJpackageDirName)
        jdkForJpackageDir.mkdirs();

        String jdkForJpackageArchiveURL = getJavaBinariesDownloadURLs.property('jdk15Binary_DownloadURL')
        String jdkForJpackageArchiveHash = getJavaBinariesDownloadURLs.property('jdk15Binary_SHA256Hash')
        String jdkForJpackageArchiveFileName = jdkForJpackageArchiveURL.tokenize('/').last()
        File jdkForJpackageFile = new File(jdkForJpackageDir, jdkForJpackageArchiveFileName)

        // Download necessary JDK binaries + verify hash
        ext.downloadAndVerifyArchive(jdkForJpackageArchiveURL, jdkForJpackageArchiveHash, jdkForJpackageFile)

        // Extract them
        String jpackageBinaryFileName
        if (Os.isFamily(Os.FAMILY_WINDOWS)) {
            ext.extractArchiveZip(jdkForJpackageFile, jdkForJpackageDir)
            jpackageBinaryFileName = 'jpackage.exe'
        } else {
            ext.extractArchiveTarGz(jdkForJpackageFile, jdkForJpackageDir)
            jpackageBinaryFileName = 'jpackage'
        }

        // Find jpackage in the newly extracted JDK
        // Don't rely on hardcoded paths to reach it, because the path depends on the version and platform
        jdkForJpackageDir.traverse(type: FILES, nameFilter: jpackageBinaryFileName) {
            println 'Using jpackage binary from ' + it
            ext.jpackageFilePath = it.path
        }
    }

    ext.downloadAndVerifyArchive = {String archiveURL, String archiveSHA256, File destinationArchiveFile ->
        println "Downloading ${archiveURL}"
        ant.get(src: archiveURL, dest: destinationArchiveFile)
        println 'Download saved to ' + destinationArchiveFile

        println 'Verifying checksum for downloaded binary ...'
        ant.jdkHash = archiveSHA256
        ant.checksum(file: destinationArchiveFile, algorithm: 'SHA-256', property: '${jdkHash}', verifyProperty: 'hashMatches')
        if (ant.properties['hashMatches'] != 'true') {
            ant.fail('Checksum mismatch: Downloaded JDK binary has a different checksum than expected')
        }
        println 'Checksum verified'
    }

    ext.extractArchiveTarGz = {File tarGzFile, File destinationDir ->
        println "Extracting tar.gz ${tarGzFile}"
        // Gradle's tar extraction preserves permissions (crucial for jpackage to function correctly)
        copy {
            from tarTree(resources.gzip(tarGzFile))
            into destinationDir
        }
        println "Extracted to ${destinationDir}"
    }

    ext.extractArchiveZip = {File zipFile, File destinationDir ->
        println "Extracting zip ${zipFile}..."
        ant.unzip(src: zipFile, dest: destinationDir)
        println "Extracted to ${destinationDir}"
    }
}

task packageInstallers {
    description 'Call jpackage to prepare platform-specific binaries for this platform'
    dependsOn 'retrieveAndExtractJavaBinaries'
    // Clean all previous artefacts and create a fresh shadowJar for the installers
    dependsOn rootProject.clean
    dependsOn ':desktop:shadowJar'

    doLast {
        String jPackageFilePath = retrieveAndExtractJavaBinaries.property('jpackageFilePath')
        String licenseFilePath = "${rootProject.projectDir}/LICENSE"
        File binariesFolderPath = file(getJavaBinariesDownloadURLs.property('binariesFolderPath'))

        File tempRootDir = getJavaBinariesDownloadURLs.property("tempRootDir")
        // The jpackateTempDir stores temp files used by jpackage for building the installers
        // It can be inspected in order to troubleshoot the packaging process
        File jpackateTempDir = new File(tempRootDir, "jpackage-temp")
        jpackateTempDir.mkdirs();

        // ALL contents of this folder will be included in the resulting installers
        // However, the fat jar is the only one we need
        // Therefore, this location should point to a folder that ONLY contains the fat jar
        // If later we will need to include other non-jar resources, we can do that by adding --resource-dir to the jpackage opts
        String fatJarFolderPath = "${project(':desktop').buildDir}/libs"
        String mainJarName = file(fatJarFolderPath).list()[0]

        // TODO For non-modular applications: use jlink to create a custom runtime containing only the modules required

        // See jpackager argument documentation:
        // https://docs.oracle.com/en/java/javase/15/docs/specs/man/jpackage.html

        // Remove the -SNAPSHOT suffix from the version string (originally defined in build.gradle)
        // Having it in would have resulted in an invalid version property for several platforms (mac, linux/rpm)
        String appVersion = version.replaceAll("-SNAPSHOT", "")
        println "Packaging Bisq version ${appVersion}"

        String commonOpts = (
                // Generic options
                " --dest \"${binariesFolderPath}\"" +
                " --name Bisq" +
                " --description \"A decentralized bitcoin exchange network.\"" +
                " --app-version ${appVersion}" +
                " --copyright \"© 2020 Bisq\"" +
                " --vendor Bisq" +
                " --temp \"${jpackateTempDir}\"" +

                // Options for creating the application image
                " --input ${fatJarFolderPath}" +

                // Options for creating the application launcher
                " --main-jar ${mainJarName}" +
                " --main-class bisq.desktop.app.BisqAppMain" +
                " --java-options -Xss1280k" +
                " --java-options -XX:MaxRAM=4g" +
                " --java-options -Djava.net.preferIPv4Stack=true" +
                // Warning: this will cause guice reflection exceptions and lead to issues with the guice internal cache
                // resulting in the UI not loading
//              " --java-options -Djdk.module.illegalAccess=deny" +

                // Options for creating the application package
                " --license-file \"${licenseFilePath}\""
        )

        if (Os.isFamily(Os.FAMILY_WINDOWS)) {
            // TODO Found no benefit in using --resource-dir "..package/windows", it has the same outcome as opts below
            // Actually using the --resource-dir option caused issues with uninstalling the newly installed Bisq
            // Therefore, not using --resource-dir for windows, for now

            String windowsOpts = (
                " --icon ${project(':desktop').projectDir}/package/windows/Bisq.ico" +
                " --win-per-user-install" +
                " --win-menu" +
                " --win-shortcut"
            )

            // TODO How does the current package/windows/Bisq.iss play into this?

            executeCmd(jPackageFilePath + commonOpts + windowsOpts + " --type exe")
        } else if (Os.isFamily(Os.FAMILY_MAC)) {
            // See https://docs.oracle.com/en/java/javase/14/jpackage/override-jpackage-resources.html
            // for details of "--resource-dir"

            String macOpts = (
                " --resource-dir \"${project(':desktop').projectDir}/package/macosx\""
            )

            // Env variable can be set by calling "export BISQ_PACKAGE_SIGNING_IDENTITY='Some value'"
            // See "man codesign" for details about the expected signing identity
            String envVariableSigningID = "$System.env.BISQ_PACKAGE_SIGNING_IDENTITY"
            println "Environment variable BISQ_PACKAGE_SIGNING_IDENTITY is: ${envVariableSigningID}"
            ant.input(message: "Sign dylibs using the above signing identity, before packaging the app? (y=yes, n=no)",
                    addproperty: "macos-sign-check",
                    validargs: "y,n")
            if (ant.properties['macos-sign-check'] == 'y') {
                // Create a temp folder to extract the macos-specific dylibs that need to be signed
                File tempDylibFolderPath = new File(tempRootDir, "dylibs-to-sign")
                tempDylibFolderPath.mkdirs();

                // Dylibs relevant for signing (paths relative to the tempDylibFolderPath)
                String dylibsToSign = (
                        " libjavafx_iio.dylib" +
                        " libglass.dylib" +
                        " libjavafx_font.dylib" +
                        " libprism_common.dylib" +
                        " libprism_es2.dylib" +
                        " libdecora_sse.dylib" +
                        " libprism_sw.dylib" +
                        " org/bridj/lib/darwin_universal/libbridj.dylib" +
                        " META-INF/native/libio_grpc_netty_shaded_netty_tcnative_osx_x86_64.jnilib" +
                        " lib/x86_64/darwin/libscrypt.dylib" +
                        " com/github/sarxos/webcam/ds/buildin/lib/darwin_universal/libOpenIMAJGrabber.dylib"
                )

                // Extract dylibss for signing
                executeCmd("cd ${tempDylibFolderPath} &&" +
                        " jar xf ${fatJarFolderPath}/${mainJarName}" +
                        dylibsToSign)

                // Sign them
                executeCmd("cd ${tempDylibFolderPath} &&" +
                        " codesign -vvv --options runtime --deep --force --sign \"${envVariableSigningID}\"" +
                        dylibsToSign)

                // Replace unsigned files in jar file
                executeCmd("cd ${tempDylibFolderPath} &&" +
                        " jar uf ${fatJarFolderPath}/${mainJarName}" +
                        dylibsToSign)
            }

            executeCmd(jPackageFilePath + commonOpts + macOpts + " --type dmg")
        } else {
            String linuxOpts = (
                " --icon ${project(':desktop').projectDir}/package/linux/icon.png" +

                // This defines the first part of the resulting packages (the application name)
                // deb requires lowercase letters, therefore the application name is written in lowercase
                " --linux-package-name bisq" +

                // This represents the linux package version (revision)
                // By convention, this is part of the deb/rpm package names, in addition to the software version
                " --linux-app-release 1" +

                " --linux-menu-group Network" +
                " --linux-shortcut"
            )

            // Package deb
            executeCmd(jPackageFilePath + commonOpts + linuxOpts +
                " --linux-deb-maintainer contact@bisq.network" +
                " --type deb")

            // Clean jpackage temp folder, needs to be empty for the next packaging step (rpm)
            jpackateTempDir.deleteDir();
            jpackateTempDir.mkdirs();

            // Package rpm
            executeCmd(jPackageFilePath + commonOpts + linuxOpts +
                " --linux-rpm-license-type AGPLv3" + // https://fedoraproject.org/wiki/Licensing:Main?rd=Licensing#Good_Licenses
                " --type rpm")
        }

        println "The binaries are ready:"
        binariesFolderPath.traverse {
            println it.path
        }
    }
}

def executeCmd(String cmd) {
    String shell
    String shellArg
    if (Os.isFamily(Os.FAMILY_WINDOWS)) {
        shell = 'cmd'
        shellArg = '/c'
    } else {
        shell = 'bash'
        shellArg = '-c'
    }

    println "Executing command:\n${cmd}\n"
    // See "Executing External Processes" section of
    // http://docs.groovy-lang.org/next/html/documentation/
    def commands = [shell, shellArg, cmd]
    def process = commands.execute(null, project.rootDir)
    if (process.waitFor() == 0) {
        println "Command output (stdout):\n${process.text}"
    } else {
        println "Command output (stderr):\n${process.err.text}"
    }
}
